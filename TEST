1. Sum of DigitsQuestion: Write a shell script to calculate the sum of digits of any number entered through the keyboard.Bash#!/bin/bash
# Script: sum_of_digits.sh
echo "Enter a number:"
read num
original_num=$num
sum=0
# Loop until the number becomes 0
while [ $num -gt 0 ]; do
    # Get the last digit (remainder when divided by 10)
    digit=$((num % 10))
    # Add the digit to the sum
    sum=$((sum + digit))
    # Remove the last digit (integer division by 10)
    num=$((num / 10))
done
echo "The sum of digits of $original_num is: $sum"
-----------------------------------------------
Execution:Bashbash sum_of_digits.sh
------------------------------------------------------------------------
2. Division and Division by Zero CheckQuestion: Write a program that displays the result of division of one integer by another and informs if the user tries to divide an integer by zero.Bash#!/bin/bash
# Script: division_check.sh
echo "Enter the dividend (numerator):"
read num1
echo "Enter the divisor (denominator):"
read num2
# Check if the divisor is zero
if [ $num2 -eq 0 ]; then
    echo "Error: Cannot divide by zero."
else
    # Calculate the result (using 'bc' for floating-point division)
    # Scale=3 sets the precision to 3 decimal places
    result=$(echo "scale=3; $num1 / $num2" | bc)
    echo "The result of $num1 divided by $num2 is: $result"
fi
Execution:Bashbash division_check.sh
3. Reverse a NumberQuestion: Write a shell program that takes a number from the user and prints the reverse of the number.Bash#!/bin/bash
# Script: reverse_number.sh
echo "Enter a number:"
read num
original_num=$num
reverse=0
while [ $num -gt 0 ]; do
    # Get the last digit
    remainder=$((num % 10))
    # Build the reversed number
    reverse=$((reverse * 10 + remainder))
    # Remove the last digit
    num=$((num / 10))
done
echo "The reverse of the number $original_num is: $reverse"
Execution:Bashbash reverse_number.sh
4. Check for Prime NumberQuestion: Write a shell script to check whether a given number is prime or not.Bash#!/bin/bash
# Script: check_prime.sh
echo "Enter a positive integer:"
read n
# 0 and 1 are not prime
if [ $n -lt 2 ]; then
    echo "$n is not a prime number."
    exit 0
fi
is_prime=1 # Assume it is prime initially
# Loop from 2 up to the square root of n (or n/2 for simplicity)
i=2
limit=$((n / 2)) # Optimization: check up to n/2
while [ $i -le $limit ]; do
    if [ $((n % i)) -eq 0 ]; then
        is_prime=0 # Found a divisor, so it's not prime
        break
    fi
    i=$((i + 1))
done
if [ $is_prime -eq 1 ]; then
    echo "$n is a prime number."
else
    echo "$n is not a prime number."
fi
Execution:Bashbash check_prime.sh
5. Check if Two Numbers are Prime to Each Other (Coprime/Relatively Prime)Question: Write a shell script to determine whether two numbers input through the keyboard are prime to each other.Two numbers are "prime to each other" (coprime or relatively prime) if their Greatest Common Divisor (GCD) is 1.Bash#!/bin/bash
# Script: check_coprime.sh
echo "Enter the first number (A):"
read a
echo "Enter the second number (B):"
read b
# Function to calculate GCD using the Euclidean algorithm
gcd() {
    local x=$1
    local y=$2
    while [ $y -ne 0 ]; do
        temp=$y
        y=$((x % y))
        x=$temp
    done
    echo $x
}
# Ensure both numbers are positive
if [ $a -le 0 ] || [ $b -le 0 ]; then
    echo "Please enter positive integers."
    exit 1
fi
result_gcd=$(gcd $a $b)
echo "The GCD of $a and $b is: $result_gcd"
if [ $result_gcd -eq 1 ]; then
    echo "The numbers $a and $b are prime to each other (coprime)."
else
    echo "The numbers $a and $b are NOT prime to each other (not coprime)."
fi
Execution:Bashbash check_coprime.sh
6. Maximum of Three Numbers (Command Line Arguments)Question: Write a shell script to show the maximum of three numbers provided as command line arguments.Bash#!/bin/bash
# Script: max_of_three.sh
# Check if exactly three arguments are provided
if [ $# -ne 3 ]; then
    echo "Usage: $0 <number1> <number2> <number3>"
    exit 1
fi
num1=$1
num2=$2
num3=$3
max=$num1
# Compare with the second number
if [ $num2 -gt $max ]; then
    max=$num2
fi
# Compare with the third number
if [ $num3 -gt $max ]; then
    max=$num3
fi
echo "The three numbers are: $num1, $num2, $num3"
echo "The maximum number is: $max"
Execution:Bashbash max_of_three.sh 15 42 7
7. Average Temperature of Last Seven DaysQuestion: Write a shell script to read the date and temperature of the last seven days and show the average temperature of the last seven days.Bash#!/bin/bash
# Script: average_temp.sh
num_days=7
total_temp=0
echo "--- Enter Data for the Last $num_days Days ---"
for ((i = 1; i <= num_days; i++)); do
    echo "Day $i:"
    # Input Date
    echo -n "  Enter date (e.g., Nov 10): "
    read date_input
    # Input Temperature
    while true; do
        echo -n "  Enter temperature (°C): "
        read temp_input
        # Simple check to ensure it's a number (can be expanded for robustness)
        if [[ $temp_input =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
            # Convert to integer for simple summation (assuming integer temperatures)
            # Use 'bc' if fractional temperatures are required for total_temp
            total_temp=$((total_temp + ${temp_input%.*}))
            break
        else
            echo "Invalid input. Please enter a numerical temperature."
        fi
    done
done
# Calculate the average (using 'bc' for floating-point calculation)
average_temp=$(echo "scale=2; $total_temp / $num_days" | bc)
echo "--- Results ---"
echo "Total temperature sum for $num_days days: $total_temp °C"
echo "The average temperature of the last $num_days days is: $average_temp °C"
Execution:Bashbash average_temp.sh
8. Salary CalculationQuestion: Ramesh’s basic salary (BASIC) is input through a keyboard. His dearness allowance (DA) is 52% of BASIC. House rent allowance (HRA) is 15% BASIC. Contributory provident fund is 12% of (BASIC + DA). Write a shell script to calculate his gross salary and take home salary using the following formula:Gross salary = BASIC + DA + HRA + (BASIC + DA) * 0.12Take home salary = BASIC + DA + HRA - (BASIC + DA) * 0.12Note: The formula provided in the question for Gross Salary seems to include the CPF component as an addition, which is unusual (CPF/PF is typically a deduction). I will follow the formulas exactly as written for both gross and take-home salary, but the calculation of DA, HRA, and CPF will be done based on their definitions.Definitions:$DA = 0.52 \times BASIC$$HRA = 0.15 \times BASIC$$CPF = 0.12 \times (BASIC + DA)$Formulas (as given in the question):$Gross\ Salary = BASIC + DA + HRA + (BASIC + DA) \times 0.12$$Take\ Home\ Salary = BASIC + DA + HRA - (BASIC + DA) \times 0.12$Bash#!/bin/bash
# Script: salary_calculator.sh
echo "Enter Ramesh's Basic Salary (BASIC):"
read basic
# Use 'bc' for floating-point arithmetic. Scale=2 for currency calculations.
# Calculate allowances and deductions
da=$(echo "scale=2; $basic * 0.52" | bc)
hra=$(echo "scale=2; $basic * 0.15" | bc)
basic_plus_da=$(echo "scale=2; $basic + $da" | bc)
cpf_component=$(echo "scale=2; $basic_plus_da * 0.12" | bc)
# Calculate Gross Salary (Following the given formula, which ADDs the CPF component)
gross_salary=$(echo "scale=2; $basic + $da + $hra + $cpf_component" | bc)
# Calculate Take Home Salary (Following the given formula, which SUBTRACTs the CPF component)
take_home_salary=$(echo "scale=2; $basic + $da + $hra - $cpf_component" | bc)
echo "--- Salary Details ---"
echo "Basic Salary (BASIC): $basic"
echo "Dearness Allowance (DA) (52% of BASIC): $da"
echo "House Rent Allowance (HRA) (15% of BASIC): $hra"
echo "Contributory PF Component (12% of BASIC+DA): $cpf_component"
echo "----------------------"
echo "Gross Salary (BASIC + DA + HRA + CPF Component): $gross_salary"
echo "Take Home Salary (BASIC + DA + HRA - CPF Component): $take_home_salary"
Execution:Bashbash salary_calculator.sh
9. Calculate Student GradeQuestion: Write a shell script to calculate the grade of students from average marks, where the marks will be taken from another file. Determine the grade as per the following rule:MarksGrade90 – 100O80 – 89E70 – 79A60 – 69B50 – 59C40 – 49FFirst, create a sample data file named student_marks.txt:Student ID,Average Marks
101,95.5
102,82
103,77.5
104,68
105,51
106,45
107,39
Bash#!/bin/bash
# Script: calculate_grade.sh
marks_file="student_marks.txt"
# Check if the file exists
if [ ! -f "$marks_file" ]; then
    echo "Error: Marks file '$marks_file' not found."
    echo "Please create a file with data in the format: Student ID,Average Marks"
    exit 1
fi
echo "--- Student Grades from $marks_file ---"
echo "ID | Avg Marks | Grade"
echo "---|-----------|------"
# Read the file line by line, skipping the header (first line)
tail -n +2 "$marks_file" | while IFS=',' read -r id avg_marks; do
    # Convert average marks to an integer for comparison
    # 'bc' can handle floating point to integer truncation
    int_marks=$(echo "scale=0; $avg_marks/1" | bc)
    
    # Determine the grade using nested if-elif-else or case statement
    if [ "$int_marks" -ge 90 ]; then
        grade="O"
    elif [ "$int_marks" -ge 80 ]; then
        grade="E"
    elif [ "$int_marks" -ge 70 ]; then
        grade="A"
    elif [ "$int_marks" -ge 60 ]; then
        grade="B"
    elif [ "$int_marks" -ge 50 ]; then
        grade="C"
    elif [ "$int_marks" -ge 40 ]; then
        # Note: The rule says 49-40 is F, and marks below 40 are usually also F
        grade="F"
    else
        grade="F"
    fi
    # Print the result
    printf "%2s | %9s | %s\n" "$id" "$avg_marks" "$grade"
done
Execution:Create the data file: nano student_marks.txt (or use the sample data provided above).Run the script:Bashbash calculate_grade.sh
10. Shell CalculatorQuestion: Write a shell script that produces a shell calculator to perform the following operations:AdditionSubtractionMultiplicationDivisionBash#!/bin/bash
# Script: simple_calculator.sh
echo "--- Simple Shell Calculator ---"
# Input numbers
echo -n "Enter the first number (Num1): "
read num1
echo -n "Enter the second number (Num2): "
read num2
# Input operation
echo "Select operation:"
echo "1. Addition (+)"
echo "2. Subtraction (-)"
echo "3. Multiplication (*)"
echo "4. Division (/)"
echo -n "Enter choice (1/2/3/4): "
read choice
result=""
# Use 'bc' for floating-point precision, set scale=3
case $choice in
    1) # Addition
        result=$(echo "scale=3; $num1 + $num2" | bc)
        operation="+"
        ;;
    2) # Subtraction
        result=$(echo "scale=3; $num1 - $num2" | bc)
        operation="-"
        ;;
    3) # Multiplication
        result=$(echo "scale=3; $num1 * $num2" | bc)
        operation="*"
        ;;
    4) # Division
        if [ $(echo "$num2 == 0" | bc) -eq 1 ]; then
            echo "Error: Division by zero!"
            exit 1
        fi
        result=$(echo "scale=3; $num1 / $num2" | bc)
        operation="/"
        ;;
    *)
        echo "Error: Invalid choice."
        exit 1
        ;;
esac
echo "--- Result ---"
echo "$num1 $operation $num2 = $result"
Execution:Bashbash simple_calculator.sh
11. Bubble SortQuestion: Write a shell script to sort a list of elements using bubble sort technique.Bash#!/bin/bash
# Script: bubble_sort.sh
echo "Enter elements separated by spaces (e.g., 5 2 9 1 5):"
read -a array # Reads all elements into an array named 'array'
n=${#array[@]} # Get the number of elements
echo "Original Array: ${array[*]}"
# Bubble Sort Algorithm
for ((i = 0; i < n - 1; i++)); do
    for ((j = 0; j < n - i - 1; j++)); do
        # Compare adjacent elements
        if [ ${array[j]} -gt ${array[j+1]} ]; then
            # Swap them if they are in the wrong order
            temp=${array[j]}
            array[j]=${array[j+1]}
            array[j+1]=$temp
        fi
    done
done
echo "Sorted Array: ${array[*]}"
Execution:Bashbash bubble_sort.sh
12. (a) Print String on Same LineQuestion: (a) How to print any string so that the cursor will stay at the same line?Answer: You can use the echo -n command or the printf command without a newline character (\n).Example Shell Script:Bash#!/bin/bash
# Script: print_sameline.sh
echo -n "Hello, "
echo -n "World! "
echo "This text will appear on the next line."
printf "Another line... "
printf "Still on the same line. \n"
echo "The cursor will move to the next line after this."
Execution:Bashbash print_sameline.sh
Output Example:Hello, World! This text will appear on the next line.
Another line... Still on the same line. 
The cursor will move to the next line after this.
12. (b) Print PatternQuestion: (b) Write a shell script to print the following pattern for any number of lines:*
* * *
* * * * *
* * * * * * *
* * * * * * * * *
Bash#!/bin/bash
# Script: print_pattern.sh
echo "Enter the number of lines for the pattern:"
read lines
# Start loop from 1 up to the number of lines
for ((i = 1; i <= lines; i++)); do
    
    # Calculate the number of stars: (2*i - 1)
    stars=$((2 * i - 1))
    
    # Print the required number of spaces (for centering, optional but nice)
    # spaces=$((lines - i))
    # for ((s = 1; s <= spaces; s++)); do
    #     echo -n " "
    # done
    # Print the stars. We need to print a string of stars with a space between them.
    # An efficient way is to use a loop to build the string.
    pattern=""
    for ((k = 1; k <= stars; k++)); do
        pattern="$pattern*"
        # Add a space after the star, unless it's the last one
        if [ $k -lt $stars ]; then
            pattern="$pattern "
        fi
    done
    
    echo "$pattern"
done
Execution:Bashbash print_pattern.sh
13. Count Consonants and VowelsQuestion: Write a shell script which counts the number of consonants and vowels in a given sentence.Bash#!/bin/bash
# Script: count_cv.sh
echo "Enter a sentence or string:"
read sentence
# Convert the input to lowercase for easier matching
sentence_lower=$(echo "$sentence" | tr '[:upper:]' '[:lower:]')
vowels=0
consonants=0
# Loop through each character in the string
for ((i = 0; i < ${#sentence_lower}; i++)); do
    char=${sentence_lower:$i:1}
    
    # Check if the character is an alphabet
    if [[ "$char" =~ [a-z] ]]; then
        
        # Check if the character is a vowel
        if [[ "$char" == "a" || "$char" == "e" || "$char" == "i" || "$char" == "o" || "$char" == "u" ]]; then
            vowels=$((vowels + 1))
        else
            # Must be a consonant
            consonants=$((consonants + 1))
        fi
    fi
done
echo "--- Results ---"
echo "Original Sentence: $sentence"
echo "Number of Vowels: $vowels"
echo "Number of Consonants: $consonants"
Execution:Bashbash count_cv.sh
14. Check String LengthQuestion: Accept a string from the terminal and echo a suitable message if it doesn’t have at least ten characters.Bash#!/bin/bash
# Script: check_length.sh
echo "Enter a string:"
read input_string
# Get the length of the string
length=${#input_string}
if [ $length -lt 10 ]; then
    echo "Message: The string is too short. It has only $length characters, but requires at least ten characters."
else
    echo "Message: The string is valid. It has $length characters."
fi
Execution:Bashbash check_length.sh
15. Drop Lines Matched with a Given WordQuestion: Write a shell script to drop the lines which are matched with a given word.The script will take the filename and the word as input, and print the resulting content to the screen.Bash#!/bin/bash
# Script: drop_matched_lines.sh
echo "Enter the filename:"
read filename
# Check if file exists
if [ ! -f "$filename" ]; then
    echo "Error: File '$filename' not found."
    exit 1
fi
echo "Enter the word to match (lines containing this word will be dropped):"
read word_to_drop
echo "--- Content of '$filename' (excluding lines with '$word_to_drop') ---"
# Use 'grep -v' to invert the match, printing all lines that DO NOT contain the word
grep -v "$word_to_drop" "$filename"
echo "------------------------------------------------------------------------"
Execution:Create a sample file: echo -e "Line one.\nThis line has the word UNIX.\nThird line is simple.\nUNIX is great." > sample.txtRun the script:Bashbash drop_matched_lines.sh
(Enter sample.txt for the filename and UNIX for the word)16. Quickly Move and Replace CharactersQuestion: How will you quickly move to the fifth word of a line and replace its four characters with something else.Answer: This task is best done using the sed or awk text processing tools, often in a single command pipeline.Using awk (Field Separator):To target the 5th word: awk '{ ... }'To modify the 5th word: Use substr() or string manipulation on $5.Using sed (Regular Expression):To replace 4 characters starting at the beginning of the 5th word. A "word" is often defined as a sequence of non-space characters.Example Command (using sed for a line in a file):This command reads a file, targets the first line (using /1p), and replaces the first four characters of the fifth word with XXXX.Bash#!/bin/bash
# Script: replace_chars.sh
echo "--- Demonstrating command for replacement ---"
echo "Creating a sample file 'demo_line.txt'..."
echo "This is the line with five important words." > demo_line.txt
# The sed command:
# 1. '^([^ ]+ +){4}': Matches the start of the line (^) and exactly four words followed by spaces.
# 2. '([^ ]{4})': Captures the first four characters of the fifth word into group 2 (\2).
# 3. 's/pattern/replacement/': The substitution command.
#    '/\1\2/' is the pattern. The replacement is '\1' (the first four words) + 'XXXX' + whatever was after the 4 replaced chars.
echo "Original Line:"
cat demo_line.txt
echo -e "\nLine after replacement:"
# This command replaces the first 4 characters of the 5th word with 'XXXX'
sed 's/^\([^ ]\+ \+\)\{4\}[^ ]\{4\}/\1XXXX/' demo_line.txt
Execution:Bashbash replace_chars.sh
Output Example:--- Demonstrating command for replacement ---
Creating a sample file 'demo_line.txt'...
Original Line:
This is the line with five important words.
Line after replacement:
This is the line with XXXXrtant words.
17. Delete Lines Containing a WordQuestion: Write a shell script which deletes all lines containing the word UNIX in the files supplied as arguments to this shell script.Bash#!/bin/bash
# Script: delete_unix_lines.sh
# Check if files were supplied as arguments
if [ $# -eq 0 ]; then
    echo "Usage: $0 <file1> [<file2> ...]"
    exit 1
fi
word="UNIX"
echo "Deleting lines containing the word '$word' in the following files:"
# Loop through all command line arguments (files)
for file in "$@"; do
    if [ -f "$file" ]; then
        echo "Processing file: $file"
        
        # Use 'grep -v' to select lines *without* the word, and redirect output to a temp file
        grep -v "$word" "$file" > "$file.tmp"
        
        # Replace the original file with the temporary file
        mv "$file.tmp" "$file"
        
        echo "  -> Lines deleted. File updated."
    else
        echo "  -> Error: '$file' is not a valid file or does not exist. Skipping."
    fi
done
echo "Done."
Execution:Create sample files:Bashecho -e "Hello World\nUNIX System V\nAnother line\nLearning UNIX" > file1.txt
echo -e "No match here\nStill no match" > file2.txt
Run the script:Bashbash delete_unix_lines.sh file1.txt file2.txt
Check the result:Bashcat file1.txt
18. Display Users and CountQuestion: Write a sequence to display the list of users as well as the number of users connected to the system.Answer: This can be done with a combination of standard UNIX commands like who or users and wc.Bash#!/bin/bash
# Script: display_users.sh
echo "--- Users Currently Connected to the System ---"
# 1. Display the list of users (using 'who')
# who - shows username, terminal, login time, etc.
echo "List of Users (Username, Terminal, Login Time):"
who
# 2. Count the number of unique logged-in users
# who | cut -d' ' -f1 : gets the username field
# sort -u : sorts and gets unique names
# wc -l : counts the lines (number of unique users)
num_users=$(who | cut -d' ' -f1 | sort -u | wc -l)
echo "-----------------------------------------------"
echo "Total Number of Unique Users Connected: $num_users"
Execution:Bashbash display_users.sh
19. Check for Valid UserQuestion: Write the shell script to check the entered user is a valid user or not.A user is considered "valid" if their account entry exists in the /etc/passwd file.Bash#!/bin/bash
# Script: check_valid_user.sh
echo "Enter the username to check:"
read username
# Use 'grep' to search for the username in the /etc/passwd file.
# The '^' ensures it matches from the start of the line, and ':' ensures it is a full username match.
if grep -q "^$username:" /etc/passwd; then
    echo "User '$username' is a VALID user on the system."
else
    echo "User '$username' is NOT a valid user on the system."
fi
Execution:Bashbash check_valid_user.sh
20. Print Last Twenty Commands of a UserQuestion: Write a shell script to print last twenty commands issued by the user. The user name is supplied as a command line argument to the script (use bash-history file).Note: The location of the history file is typically ~/.bash_history for the current user. To access another user's history file, the script must have permission to read it (which often requires superuser privileges or the user's home directory to be world-readable). This script will assume the history file is accessible at the standard location, which is usually only true for the current user.Bash#!/bin/bash
# Script: last_twenty_commands.sh
# Check for username argument
if [ $# -ne 1 ]; then
    echo "Usage: $0 <username>"
    exit 1
fi
target_user=$1
user_home=$(eval echo ~$target_user) # Get the home directory of the user
history_file="$user_home/.bash_history"
echo "--- Last 20 Commands for User: $target_user ---"
if [ ! -f "$history_file" ]; then
    echo "Error: History file not found or inaccessible at: $history_file"
    echo "Note: History files are often only readable by the owner."
    exit 1
fi
# Use 'tail -n 20' to get the last 20 lines (commands)
tail -n 20 "$history_file"
echo "------------------------------------------------"
Execution:Bashbash last_twenty_commands.sh $(whoami)
21. Login Greeting Based on TimeQuestion: Write a shell script, which gets executed the moment a user logs in. It should display the message “GOOD MORNING” or “GOOD AFTERNOON” or “GOOD EVENING” depending upon the time at which the user logs in.Note: To execute a script automatically on login, you would place the commands inside the user's shell startup files, such as ~/.bashrc, ~/.profile, or ~/.bash_profile. The example below provides the script logic.Bash#!/bin/bash
# Script: login_greeting.sh
# Get the current hour (00-23)
current_hour=$(date +%H)
# Check the time range
if [ "$current_hour" -ge 05 ] && [ "$current_hour" -lt 12 ]; then
    GREETING="GOOD MORNING"
elif [ "$current_hour" -ge 12 ] && [ "$current_hour" -lt 17 ]; then
    GREETING="GOOD AFTERNOON"
else
    GREETING="GOOD EVENING"
fi
echo "$GREETING, $USER!" # $USER is a built-in variable containing the current username
# To make this execute on login, you would add the following line
# to your ~/.bashrc or ~/.profile:
# bash /path/to/login_greeting.sh
Execution:Bashbash login_greeting.sh
22. Login Message and DateQuestion: Write a shell program, which displays the message” welcome” and prints the date when you login to your system.Note: Similar to the previous question, this is typically added to a user's startup file (~/.bashrc or ~/.profile).Bash#!/bin/bash
# Script: welcome_and_date.sh
echo "Welcome, $USER!"
echo "Current Date and Time: $(date)"
# To make this execute on login, you would add the following line
# to your ~/.bashrc or ~/.profile:
# bash /path/to/welcome_and_date.sh
Execution:Bashbash welcome_and_date.sh
23. File Report by Size and Date (July, >500 Bytes)Question: Write a shell script, which reports names and sizes of all files in a directory (directory should be supplied as an argument to the shell script) which size exceeds 500 bytes (files are created in the month of july). The filenames should be printed in decreasing order of their sizes (their creation/modification date). The total number of such files should also be reported.Note: Filtering by "creation date" is difficult/impossible with standard find. Filtering by "modification date in July" is challenging as it depends on the year. I will use modification month of July and sort by size as requested.Bash#!/bin/bash
# Script: file_report.sh
# Check for directory argument
if [ $# -ne 1 ]; then
    echo "Usage: $0 <directory_path>"
    exit 1
fi
target_dir="$1"
file_count=0
if [ ! -d "$target_dir" ]; then
    echo "Error: Directory '$target_dir' not found."
    exit 1
fi
echo "--- File Report for Directory: $target_dir ---"
echo "Filtering for files > 500 bytes AND modified in July."
# Use 'find' to locate files, 'xargs' to get 'ls -l' info, and 'awk/grep' to filter/sort.
# 1. find . -type f: find regular files.
# 2. -size +500c: filter for files larger than 500 characters/bytes.
# 3. -exec ls -l --time-style=+%b%d {} +: list details, showing month (Jul) for filtering.
# 4. grep 'Jul': filter for files modified in July.
# 5. sort -k 5 -nr: sort by 5th column (size) numerically (-n) in reverse (-r).
file_list=$(find "$target_dir" -type f -size +500c -exec ls -l --time-style=+%b%d,%s,%H:%M {} + 2>/dev/null | \
    grep 'Jul' | \
    sort -k 5 -nr)
if [ -z "$file_list" ]; then
    echo "No files found matching the criteria."
else
    echo "--------------------------------------------------------------------------------"
    echo "Size (bytes) | Modified Date | File Name"
    echo "--------------------------------------------------------------------------------"
    
    # Process the sorted list
    echo "$file_list" | while read -r perm links user group size date_time filename; do
        # The 'ls -l' output is complex. Re-parsing is tricky. Let's use 'awk' for cleaner output.
        # A simpler approach is to count and print the lines of the sorted list.
        echo "$file_list" | awk '{
            size=$5; 
            month=$6; 
            day=$7; 
            time_or_year=$8; 
            filename=$9;
            printf "%12s | %s %s %s | %s\n", size, month, day, time_or_year, filename
        }'
        
        # Count the number of files by counting lines
        file_count=$(echo "$file_list" | wc -l)
    done
    
    echo "--------------------------------------------------------------------------------"
    echo "Total number of matching files: $file_count"
fi
Execution:Bashbash file_report.sh /path/to/directory
24. Files with Read, Write, Execute PermissionsQuestion: Write a shell script, which displays a list of all files in the current directory to which you have read, write and executes permissions.Bash#!/bin/bash
# Script: check_permissions.sh
current_dir=$(pwd)
echo "--- Files in $current_dir with Read, Write, and Execute Permissions (rwx) ---"
file_count=0
# Loop through all files and directories in the current directory
for item in *; do
    # Check if the item is a regular file AND the current user has rwx permissions
    if [ -f "$item" ] && [ -r "$item" ] && [ -w "$item" ] && [ -x "$item" ]; then
        # Use ls -l to display permissions along with the name
        ls -l "$item"
        file_count=$((file_count + 1))
    fi
done
echo "--------------------------------------------------------------------"
echo "Total number of files with rwx permissions: $file_count"
Execution:Create a file with rwx permissions: touch test_rwx.txt && chmod 700 test_rwx.txtRun the script:Bashbash check_permissions.sh
25. Display Last Modification TimeQuestion: Write a shell command that accept a filename as argument and displays the last modification time, if the file exists and a suitable message if it does not.Bash#!/bin/bash
# Script: last_mod_time.sh
# Check if a filename argument was provided
if [ $# -ne 1 ]; then
    echo "Usage: $0 <filename>"
    exit 1
fi
filename="$1"
if [ -f "$filename" ]; then
    echo "File '$filename' exists."
    # Use 'stat' for detailed file information, specifically focusing on modification time (%y)
    mod_time=$(stat -c "%y" "$filename")
    echo "Last Modification Time: $mod_time"
else
    echo "Error: File '$filename' does not exist in the current directory."
fi
Execution:Bashbash last_mod_time.sh some_file.txt
26. Find File Mod Time and Valid UserQuestion: Write a shell script which finds out the following:a. the last modification time of a fileb. whether the command line input string is a valid user or notBash#!/bin/bash
# Script: info_finder.sh
# Check for both arguments
if [ $# -ne 2 ]; then
    echo "Usage: $0 <filename> <username>"
    exit 1
fi
filename="$1"
username="$2"
echo "--- Information Report ---"
# --- Part a: Last Modification Time ---
echo "a. Checking file '$filename':"
if [ -f "$filename" ]; then
    # Use 'stat' to get modification time in a readable format
    mod_time=$(stat -c "%y" "$filename")
    echo "   -> Last Modification Time: $mod_time"
else
    echo "   -> Error: File '$filename' does not exist."
fi
# --- Part b: Valid User Check ---
echo -e "\nb. Checking user '$username':"
# Use 'grep' to search for the username in /etc/passwd
if grep -q "^$username:" /etc/passwd; then
    echo "   -> User '$username' is a VALID user on the system."
else
    echo "   -> User '$username' is NOT a valid user on the system."
fi
Execution:Bashbash info_finder.sh /etc/passwd $(whoami)
27. Files Updated in Last Fourteen DaysQuestion: Write a shell script to display the files created or updated fourteen days before from the current date. - in last 14 daysNote: The prompt seems to have conflicting phrasing ("fourteen days before" vs. "in last 14 days"). I will assume the intended request is to find files modified within the last 14 days.Bash#!/bin/bash
# Script: recent_files.sh
echo "--- Files Modified or Created in the Last 14 Days ---"
# Use 'find' to search for files in the current directory ('.')
# -type f : Only look for regular files
# -mtime -14 : Look for files whose data was last modified less than 14 * 24 hours ago
# -ls : List the detailed file information (like ls -l but includes inode, etc.)
find . -type f -mtime -14 -exec ls -l {} + 2>/dev/null
echo "----------------------------------------------------"
Execution:Bashbash recent_files.sh
28. Files Modified in November Starting with P/pQuestion: Develop a shell script which displays all files with all attributes those have created or modified in the month of November. - Names of the file starting with P/pNote: Filtering by "created" is difficult. I will use modification month of November. The attributes will be displayed using ls -l.Bash#!/bin/bash
# Script: november_p_files.sh
echo "--- Files (Starting with P/p) Modified in November ---"
# 1. find . -type f: find regular files.
# 2. -name '[Pp]*': filter for files starting with 'P' or 'p'.
# 3. -exec ls -l --time-style=+%b {} +: list details, showing month (Nov) for filtering.
# 4. grep 'Nov': filter for files modified in November.
find . -type f -name '[Pp]*' -exec ls -l --time-style=+%b {} + 2>/dev/null | grep 'Nov'
Execution:Create a sample file (if November is not the current month, you may not see output): touch project_nov.txt && touch P_file.txtRun the script:Bashbash november_p_files.sh
29. Non-Directory Files Size SumQuestion: Write a shell script that shows the names of all the non-directory files in the current directory and calculates the sum of the size of them.Bash#!/bin/bash
# Script: non_dir_size_sum.sh
current_dir=$(pwd)
total_size=0
echo "--- Non-Directory Files in $current_dir and Total Size ---"
echo "File Names:"
# Use 'find' to locate only regular files (-type f) in the current directory
# Print the name and size, and sum the sizes
find . -maxdepth 1 -type f -print0 | while IFS= read -r -d $'\0' file; do
    # Remove the './' prefix for cleaner display
    display_name="${file#./}"
    echo "  $display_name"
    
    # Get the size in bytes (using -printf '%s')
    size=$(stat -c "%s" "$file")
    
    # Add to the total size
    total_size=$((total_size + size))
done
echo "--------------------------------------------------------"
echo "Total Size of all non-directory files: $total_size bytes"
Execution:Create a file: echo "Hello" > small.txtRun the script:Bashbash non_dir_size_sum.sh
30. Files Starting with VowelsQuestion: Write a shell script to list the name of files under the current directory started with vowels.Bash#!/bin/bash
# Script: vowel_start_files.sh
current_dir=$(pwd)
echo "--- Files in $current_dir Starting with a Vowel (A, E, I, O, U) ---"
# Use 'ls' with brace expansion and globbing to match files starting with vowels (case-insensitive if GLOBIGNORE is set)
# We will use a case-insensitive find for robustness
# [AEIOUaeiou]* matches files starting with A, E, I, O, U, a, e, i, o, or u
# The standard shell command (using global pattern matching):
# ls -d [AEIOUaeiou]* 2>/dev/null
# A more robust script using find:
find . -maxdepth 1 -type f -regex '.*/[AEIOUaeiou].*' -exec basename {} \; 2>/dev/null
# Note: basename is used to remove the './' prefix.
# Fallback/simpler globbing approach:
files=$(ls -d [AEIOUaeiou]* 2>/dev/null)
if [ -z "$files" ]; then
    echo "No files found starting with a vowel."
else
    echo "$files"
fi
Execution:Create sample files: touch apple.txt orange.log banana.datRun the script:Bashbash vowel_start_files.sh
31. Delete Identical Files in bar2Question: Write a shell script that accepts two directory names bar1 and bar2 as arguments and deletes those files in bar2 which are identical to their names in bar1.Note: "Identical to their names" means the files must have the same name, e.g., if bar1/data.txt exists, then bar2/data.txt should be deleted. This script does not check the content of the files.Bash#!/bin/bash
# Script: delete_identical_names.sh
# Check for two arguments
if [ $# -ne 2 ]; then
    echo "Usage: $0 <dir_bar1> <dir_bar2>"
    exit 1
fi
bar1="$1"
bar2="$2"
# Check if both directories exist
if [ ! -d "$bar1" ] || [ ! -d "$bar2" ]; then
    echo "Error: Both directories '$bar1' and '$bar2' must exist."
    exit 1
fi
echo "--- Deleting files in '$bar2' that share a name with a file in '$bar1' ---"
deleted_count=0
# Loop through all files in bar1 (including hidden files)
find "$bar1" -type f -maxdepth 1 -print0 | while IFS= read -r -d $'\0' file_path_bar1; do
    
    # Extract just the filename (e.g., 'data.txt')
    filename=$(basename "$file_path_bar1")
    
    # Construct the corresponding path in bar2
    file_path_bar2="$bar2/$filename"
    
    # Check if the file with the same name exists in bar2 AND is a regular file
    if [ -f "$file_path_bar2" ]; then
        echo "Deleting: $file_path_bar2 (matched name with file in $bar1)"
        rm "$file_path_bar2"
        deleted_count=$((deleted_count + 1))
    fi
done
echo "----------------------------------------------------------------------------------"
echo "Completed. Total files deleted from '$bar2': $deleted_count"
Execution:Create directories and sample files:Bashmkdir bar1 bar2
echo "content1" > bar1/fileA.txt
echo "content2" > bar1/fileB.txt
echo "content3" > bar2/fileA.txt
echo "content4" > bar2/fileC.txt
Run the script:Bashbash delete_identical_names.sh bar1 bar2
32. Compare Directory File CountsQuestion: Write a shell script which reads a directory name and compares the files in the current directory which has more files and how much more files.Bash#!/bin/bash
# Script: compare_dir_files.sh
echo "Enter a directory name for comparison:"
read external_dir
current_dir="." # Current directory
# Check if the external directory exists
if [ ! -d "$external_dir" ]; then
    echo "Error: Directory '$external_dir' not found."
    exit 1
fi
echo "--- Comparing file counts between '$current_dir' and '$external_dir' ---"
# Function to count non-directory files
count_files() {
    # find . -maxdepth 1 -type f | wc -l
    # -maxdepth 1: prevents recursion
    # -type f: counts only regular files (excludes directories, links, etc.)
    find "$1" -maxdepth 1 -type f 2>/dev/null | wc -l
}
current_count=$(count_files "$current_dir")
external_count=$(count_files "$external_dir")
echo "Current Directory ($current_dir) has $current_count files."
echo "External Directory ($external_dir) has $external_count files."
if [ "$current_count" -gt "$external_count" ]; then
    difference=$((current_count - external_count))
    echo "Result: The Current Directory has more files (by $difference files)."
elif [ "$external_count" -gt "$current_count" ]; then
    difference=$((external_count - current_count))
    echo "Result: The External Directory has more files (by $difference files)."
else
    echo "Result: Both directories have the same number of files ($current_count)."
fi
Execution:Create a test directory: mkdir test_dir && touch test_dir/a test_dir/bRun the script:Bashbash compare_dir_files.sh
(Enter test_dir for the directory name)33. Check for Blank FileQuestion: Write a shell script to check the entered file is a blank file or not. If not found blank then display the contents of the file.Note: A "blank file" typically means an empty file with a size of 0 bytes.Bash#!/bin/bash
# Script: check_blank_file.sh
echo "Enter the filename to check:"
read filename
# Check if the file exists and is a regular file
if [ ! -f "$filename" ]; then
    echo "Error: File '$filename' not found or is not a regular file."
    exit 1
fi
# Check if the file size is zero using the -s flag (true if file is not zero size)
if [ ! -s "$filename" ]; then
    echo "The file '$filename' is a BLANK (empty) file (size 0 bytes)."
else
    echo "The file '$filename' is NOT a blank file. Contents are:"
    echo "--------------------------------------------------------"
    cat "$filename"
    echo "--------------------------------------------------------"
fi
Execution:Create an empty file: touch blank.txtCreate a non-empty file: echo "some content" > full.txtRun the script:Bashbash check_blank_file.sh
(Enter blank.txt then run again and enter full.txt)34. File Stats and Type CheckQuestion: Write a shell script to find the total number of words, characters, lines in the given file (supplied as command line argument) and check if it is a regular file or not.Bash#!/bin/bash
# Script: file_stats.sh
# Check for filename argument
if [ $# -ne 1 ]; then
    echo "Usage: $0 <filename>"
    exit 1
fi
filename="$1"
echo "--- File Analysis for '$filename' ---"
# --- Part 1: Check File Type ---
if [ -f "$filename" ]; then
    echo "File Type: REGULAR File (Check Passed)"
    
    # --- Part 2: Count Stats ---
    # Use 'wc' command (word count)
    # wc -l: lines
    # wc -w: words
    # wc -m: characters (bytes can be used with -c, but -m is better for multi-byte chars)
    
    stats=$(wc -l -w -m "$filename")
    # Output of wc:  LINES  WORDS  CHARS  filename
    
    # Read the stats into variables
    read -r lines words chars <<< "$stats"
    
    echo "------------------------------------"
    echo "Total Lines: $lines"
    echo "Total Words: $words"
    echo "Total Characters: $chars"
    echo "------------------------------------"
elif [ -d "$filename" ]; then
    echo "File Type: DIRECTORY (Not a regular file)"
else
    echo "File Type: Other (e.g., device, link) or does not exist."
fi
Execution:Bashbash file_stats.sh /etc/passwd
35. Concatenate and Count StatsQuestion: Write a shell script to concatenate two files and count the number of characters, number of words and number of lines in the resultant concatenated file.Bash#!/bin/bash
# Script: concatenate_and_count.sh
echo "Enter the name of the first file (File1):"
read file1
echo "Enter the name of the second file (File2):"
read file2
output_file="concatenated_output.txt"
# Check if both files exist
if [ ! -f "$file1" ] || [ ! -f "$file2" ]; then
    echo "Error: One or both files not found."
    exit 1
fi
echo "--- Concatenating Files ---"
# Concatenate files and save to the output file
cat "$file1" "$file2" > "$output_file"
echo "Successfully concatenated '$file1' and '$file2' into '$output_file'."
echo "--- Resultant File Statistics ---"
# Use 'wc' on the output file
stats=$(wc -l -w -m "$output_file")
read -r lines words chars <<< "$stats"
echo "Lines: $lines"
echo "Words: $words"
echo "Characters: $chars"
# Optionally clean up the temporary concatenated file
# rm "$output_file"
Execution:Create sample files: echo "Hello" > f1.txt; echo "World" > f2.txtRun the script:Bashbash concatenate_and_count.sh
(Enter f1.txt and f2.txt)36. Duplicate File Check and ActionQuestion: Write a shell script to take the two filename as an input and if they are not duplicate file then concatenate them otherwise delete the second one.Note: A "duplicate file" is typically one that has identical content. We can check this using the cmp (compare) utility or md5sum for a more robust check. We will use cmp which is faster for simple comparison.Bash#!/bin/bash
# Script: duplicate_check_action.sh
echo "Enter the name of the first file (File1):"
read file1
echo "Enter the name of the second file (File2):"
read file2
# Check if both files exist and are regular files
if [ ! -f "$file1" ] || [ ! -f "$file2" ]; then
    echo "Error: One or both files not found or not regular files."
    exit 1
fi
# Compare the contents of the two files
# cmp -s compares files silently. Returns 0 if identical, non-zero otherwise.
if cmp -s "$file1" "$file2"; then
    echo "File '$file1' and file '$file2' are DUPLICATE (identical content)."
    
    # Delete the second file
    echo "Action: Deleting '$file2'."
    rm "$file2"
    echo "Deletion complete."
else
    echo "File '$file1' and file '$file2' are NOT DUPLICATE (different content)."
    
    # Concatenate the files
    output_file="concatenated_output.txt"
    echo "Action: Concatenating '$file1' and '$file2' into '$output_file'."
    cat "$file1" "$file2" > "$output_file"
    echo "Concatenation complete."
fi
Execution:Create sample files:Bashecho "unique content" > u1.txt
echo "unique content" > u2.txt
echo "different content" > d1.txt
Run the script (Duplicate case):Bashbash duplicate_check_action.sh
(Enter u1.txt and u2.txt)Run the script (Non-duplicate case):Bashbash duplicate_check_action.sh
(Enter u1.txt and d1.txt)37. Display Detailed File InformationQuestion: Write a shell script, which will receive either the filename or the filename with its full path during execution. This script should print information about the file as given by ls –l command and display it in an informative manner.Bash#!/bin/bash
# Script: detailed_file_info.sh
# Check for filename argument
if [ $# -ne 1 ]; then
    echo "Usage: $0 <filename_or_path>"
    exit 1
fi
file_path="$1"
# Check if the file/path exists
if [ ! -e "$file_path" ]; then
    echo "Error: The path/file '$file_path' does not exist."
    exit 1
fi
echo "--- Detailed Information for: $file_path ---"
# Get the detailed ls -l output
ls_info=$(ls -ld "$file_path")
# Use awk to parse the ls -l output:
# $1=Permissions, $2=Links, $3=Owner, $4=Group, $5=Size, $6-8=Date/Time, $9=Name
permissions=$(echo "$ls_info" | awk '{print $1}')
owner=$(echo "$ls_info" | awk '{print $3}')
group=$(echo "$ls_info" | awk '{print $4}')
size=$(echo "$ls_info" | awk '{print $5}')
mod_date=$(echo "$ls_info" | awk '{print $6, $7, $8}')
# Also use 'stat' for more precise/structured data
file_type=$(stat -c "%F" "$file_path")
echo "File Type: $file_type"
echo "Permissions (Symbolic): $permissions"
echo "Owner: $owner"
echo "Group: $group"
echo "Size: $size bytes"
echo "Last Modified: $mod_date"
echo "Absolute Path: $(readlink -f "$file_path")"
echo "--------------------------------------------------------"
Execution:Bashbash detailed_file_info.sh /etc/passwd
38. Decipher /etc/passwd InformationQuestion: The file /etc/password contains information about all the users. However, it is difficult to decipher the information stored in it. Write a shell script which would receive the log name during execution, obtain information about it from /etc/password and display this information on screen in easily understandable format.The fields in /etc/passwd (separated by :) are:UsernamePassword (usually x for shadow passwords)User ID (UID)Group ID (GID)User ID Info/Comment (GECOS)Home DirectoryLogin ShellBash#!/bin/bash
# Script: decipher_passwd.sh
# Check for username argument
if [ $# -ne 1 ]; then
    echo "Usage: $0 <username>"
    exit 1
fi
username="$1"
passwd_file="/etc/passwd"
echo "--- User Account Information for: $username ---"
# Use grep to find the line for the user
user_line=$(grep "^$username:" "$passwd_file")
if [ -z "$user_line" ]; then
    echo "Error: User '$username' not found in $passwd_file."
    exit 1
fi
# Use cut to extract the fields
# -d: delimiter is colon (:)
# -f: field number
uid=$(echo "$user_line" | cut -d: -f3)
gid=$(echo "$user_line" | cut -d: -f4)
gecos=$(echo "$user_line" | cut -d: -f5)
home_dir=$(echo "$user_line" | cut -d: -f6)
login_shell=$(echo "$user_line" | cut -d: -f7)
# Display the information in a readable format
echo "Username: $username"
echo "User ID (UID): $uid"
echo "Group ID (GID): $gid"
echo "Full Name/Comment (GECOS): $gecos"
echo "Home Directory: $home_dir"
echo "Login Shell: $login_shell"
echo "--------------------------------------------------------"
Execution:Bashbash decipher_passwd.sh $(whoami)
39. Password-Based Menu-Driven ProgramQuestion: Write a shell script to make a password-based menu-driven program, which will give three chances to enter the password in case of wrong password. If the given password is correct then the program will show thea) Number of users currently logged in.b) Calendar of current month.c) Date in the format: dd / mm / yyyy.d) ExitBash#!/bin/bash
# Script: password_menu.sh
# Define the correct password
CORRECT_PASS="secret123"
MAX_ATTEMPTS=3
# --- Authentication Loop ---
authenticate() {
    for ((attempt = 1; attempt <= MAX_ATTEMPTS; attempt++)); do
        echo -n "Enter password (Attempt $attempt/$MAX_ATTEMPTS): "
        read -s entered_pass # -s for silent input
        echo # Print a newline after silent read
        if [ "$entered_pass" = "$CORRECT_PASS" ]; then
            return 0 # Success
        else
            echo "Incorrect password."
        fi
    done
    return 1 # Failure
}
# --- Menu Function ---
show_menu() {
    while true; do
        echo -e "\n--- Main Menu ---"
        echo "a) Number of users currently logged in"
        echo "b) Calendar of current month"
        echo "c) Date in the format: dd / mm / yyyy"
        echo "d) Exit"
        echo -n "Enter choice (a/b/c/d): "
        read choice
        case "$choice" in
            a|A)
                echo -e "\n[a] Currently logged-in users:"
                who | cut -d' ' -f1 | sort -u | wc -l
                ;;
            b|B)
                echo -e "\n[b] Calendar of current month:"
                cal
                ;;
            c|C)
                echo -e "\n[c] Date:"
                date "+%d / %m / %Y"
                ;;
            d|D)
                echo -e "\nExiting program. Goodbye!"
                exit 0
                ;;
            *)
                echo "Invalid choice. Please select a, b, c, or d."
                ;;
        esac
    done
}
# --- Main Program Execution ---
if authenticate; then
    echo "Authentication successful!"
    show_menu
else
    echo "Authentication failed after $MAX_ATTEMPTS attempts. Exiting."
    exit 1
fi
Execution:Bashbash password_menu.sh
40. Simple Menu-Driven ProgramQuestion: Device a menu-driven shell program which accepts values 1 to 4 and performs actions depending upon the number keyed in:List of filesPresent dateUsers of the systemQuit to UNIX.Bash#!/bin/bash
# Script: simple_menu.sh
while true; do
    echo -e "\n--- Menu ---"
    echo "1. List of files (in current directory)"
    echo "2. Present date"
    echo "3. Users of the system"
    echo "4. Quit to UNIX"
    echo -n "Enter choice (1-4): "
    read choice
    case "$choice" in
        1)
            echo -e "\n[1] List of files (long format):"
            ls -l
            ;;
        2)
            echo -e "\n[2] Present date:"
            date
            ;;
        3)
            echo -e "\n[3] Users of the system (currently logged in):"
            who
            ;;
        4)
            echo -e "\n[4] Quitting to UNIX. Goodbye!"
            exit 0
            ;;
        *)
            echo "Invalid choice. Please select a number between 1 and 4."
            ;;
    esac
done
Execution:Bashbash simple_menu.sh
-----------------------------------------------
Process Management Assignments (41-51)
41. Get PID of Parent and Child Process
Question: Write a program to get the PID of parent and child process.
C
// File: pid_info.c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
int main() {
    pid_t pid;
    
    // Get the parent process PID before forking
    printf("Initial Process PID (before fork): %d\n", getpid());
    printf("Initial Parent PID (PPID): %d\n", getppid());
    
    pid = fork();
    
    if (pid < 0) {
        // Fork failed
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        // Child process
        printf("\n--- Child Process ---\n");
        printf("Child PID: %d\n", getpid());
        printf("Child's Parent PID (PPID): %d\n", getppid());
    } else {
        // Parent process
        // In the parent, 'pid' holds the PID of the newly created child
        printf("\n--- Parent Process ---\n");
        printf("Parent PID: %d\n", getpid());
        printf("Parent's Parent PID (PPID): %d\n", getppid());
        printf("PID of the created Child: %d\n", pid);
    }
    
    return 0;
}
Execution:
Bash
gcc pid_info.c -o pid_info
./pid_info
42. Kill All Processes Whose PID is Even
Question: Write a program to kill all processes whose PID is even.
Note: This program is highly dangerous and impractical to run with standard user permissions, as it attempts to kill all even-PID processes on the system, which includes critical services. The code below focuses only on the processes the user owns and has permissions to kill. A user cannot kill other users' processes or critical system processes without root privileges. We iterate through a small range of PIDs to demonstrate the concept.
C
// File: kill_even_pid.c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#define MAX_PID_CHECK 10000 // Only check up to this PID
int main() {
    printf("WARNING: This program attempts to kill processes with EVEN PIDs.\n");
    printf("It will only succeed on processes you own and have permission to kill.\n");
    printf("Checking PIDs up to %d...\n", MAX_PID_CHECK);
    for (int pid = 2; pid < MAX_PID_CHECK; pid += 2) {
        if (pid % 2 == 0) {
            // Attempt to send SIGKILL (9) to the process
            // kill() returns 0 on success, -1 on failure
            if (kill(pid, SIGKILL) == 0) {
                printf("Successfully sent SIGKILL to even PID: %d\n", pid);
            } else {
                // Check if the error is due to "No such process" (ESRCH) or "Permission denied" (EPERM)
                // perror is used to print the system error message if the kill call fails
                // We ignore the error for non-existent processes
                if (errno != ESRCH) {
                    // Print other errors, like Permission denied
                    // fprintf(stderr, "Failed to kill PID %d: ", pid);
                    // perror(""); 
                }
            }
        }
    }
    printf("Even PID kill attempt complete.\n");
    return 0;
}
Execution:
Bash
gcc kill_even_pid.c -o kill_even_pid
./kill_even_pid 
43. Implement an Orphan Process
Question: Implement an orphan process using fork.
An orphan process occurs when the parent process terminates before its child process finishes execution. The child process is then reparented by the init process (PID 1, or systemd/upstart equivalent).
C
// File: orphan_process.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
int main() {
    pid_t pid = fork();
    if (pid < 0) {
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        // Child Process
        printf("CHILD: PID %d, PPID (Original Parent) %d\n", getpid(), getppid());
        printf("CHILD: Parent is about to terminate. I will be orphaned.\n");
        
        // Wait for a few seconds to ensure the parent terminates first
        sleep(3); 
        
        // Now, the parent (PPID) should be 1 (or the init equivalent)
        printf("CHILD: I am now an ORPHAN. My new PPID is: %d\n", getppid());
        
        // Keep the child running for a bit to observe
        printf("CHILD: Running for 5 more seconds...\n");
        sleep(5);
        printf("CHILD: Exiting.\n");
        exit(0);
    } else {
        // Parent Process
        printf("PARENT: PID %d, Created Child PID %d\n", getpid(), pid);
        printf("PARENT: Exiting immediately to orphan the child.\n");
        exit(0); // Parent terminates quickly
    }
}
Execution:
Bash
gcc orphan_process.c -o orphan_process
./orphan_process
// After running, quickly check the PPID of the child in a separate terminal:
// ps -f --ppid 1 
// (or check the child's PID against 'ps -f')
44. Implement a Zombie Process
Question: Implement a zombie process using fork.
A zombie process occurs when a child process terminates, but its parent process hasn't called wait() (or waitpid()) to collect the child's exit status. The child process remains in the process table as a 'zombie' (Z state) until the parent calls wait() or terminates itself.
C
// File: zombie_process.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
int main() {
    pid_t pid = fork();
    if (pid < 0) {
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        // Child Process
        printf("CHILD: PID %d. I will exit immediately.\n", getpid());
        exit(0); // Child terminates
    } else {
        // Parent Process
        printf("PARENT: PID %d, Created Child PID %d\n", getpid(), pid);
        printf("PARENT: Child has terminated, but I WILL NOT call wait().\n");
        printf("PARENT: Child process %d is now a ZOMBIE.\n", pid);
        
        // Keep the parent running for a while so the zombie persists
        printf("PARENT: Sleeping for 15 seconds. Use 'ps -f' to see the zombie.\n");
        sleep(15);
        
        printf("PARENT: Exiting. The init process will now reap the zombie.\n");
    }
    return 0;
}
Execution:
Bash
gcc zombie_process.c -o zombie_process
./zombie_process & // Run in background to keep the terminal prompt free
// Quickly run in a separate terminal to view the 'Z' status:
// ps -f | grep zombie_process
45. Local and Global Variables with fork()
Question: Write a program with a local variable and a global variable. Initialize both of them. The program should fork a child process and the child should increment both the variables by one. After this operation, both the parent and the child should print the values of the variables.
Key Concept: When fork() is called, the child process receives a copy of the parent's memory space, including the initialized variables. Changes made by the child are not visible to the parent, and vice versa.
C
// File: var_fork.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
// Global variable
int global_var = 10;
int main() {
    // Local variable
    int local_var = 20;
    pid_t pid;
    printf("--- Before Fork ---\n");
    printf("Initial Global variable: %d\n", global_var);
    printf("Initial Local variable: %d\n", local_var);
    
    pid = fork();
    
    if (pid < 0) {
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        // Child process
        printf("\n--- Child Process (%d) ---\n", getpid());
        
        // Increment variables in child's memory copy
        global_var++;
        local_var++;
        
        printf("Child: Incremented Global variable: %d\n", global_var);
        printf("Child: Incremented Local variable: %d\n", local_var);
        exit(0); // Child finishes
    } else {
        // Parent process
        
        // Parent waits for the child to finish
        wait(NULL); 
        
        printf("\n--- Parent Process (%d) ---\n", getpid());
        
        // Print variables in parent's memory
        // These values should be the original values because the child modified its copy.
        printf("Parent: Global variable (after child increment): %d\n", global_var);
        printf("Parent: Local variable (after child increment): %d\n", local_var);
    }
    
    return 0;
}
Execution:
Bash
gcc var_fork.c -o var_fork
./var_fork
46. Local and Global Variables with vfork()
Question: Implement the assignment no. 47 using vfork for spawning the child.
Correction: This assignment refers to Assignment 45 (Local/Global Variables), not 47. Key Concept: vfork() guarantees that the child runs first in the parent's address space. The parent is suspended until the child calls exec() or _exit(). Any changes the child makes to variables will be reflected in the parent's memory. This is generally dangerous, but necessary to show the difference.
C
// File: var_vfork.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
// Global variable
int global_var = 10;
int main() {
    // Local variable
    int local_var = 20;
    pid_t pid;
    printf("--- Before vfork ---\n");
    printf("Initial Global variable: %d\n", global_var);
    printf("Initial Local variable: %d\n", local_var);
    
    pid = vfork();
    
    if (pid < 0) {
        perror("vfork failed");
        return 1;
    } else if (pid == 0) {
        // Child process (runs first, sharing memory with parent)
        printf("\n--- Child Process (%d) ---\n", getpid());
        
        // Increment variables. THIS DIRECTLY MODIFIES THE PARENT'S MEMORY!
        global_var++;
        local_var++;
        
        printf("Child: Incremented Global variable: %d\n", global_var);
        printf("Child: Incremented Local variable: %d\n", local_var);
        
        // MUST use _exit() with vfork to avoid memory corruption in the parent
        _exit(0); 
    } else {
        // Parent process (resumes after child calls _exit())
        
        printf("\n--- Parent Process (%d) ---\n", getpid());
        
        // Print variables in parent's memory
        // These values SHOULD be the modified values from the child.
        printf("Parent: Global variable (after child increment): %d\n", global_var); // Expected: 11
        printf("Parent: Local variable (after child increment): %d\n", local_var);   // Expected: 21
    }
    
    return 0;
}
Execution:
Bash
gcc var_vfork.c -o var_vfork
./var_vfork
47. Background Process with System Info
Question: Write a program to create a process which will run as a background process for fifty seconds and at the time of execution it will print the system information.
To run as a "background process" (daemon/detached), the child process must usually: 1) Call fork(). 2) The parent must exit. 3) The child must call setsid() to detach from the terminal and create a new session. 4) The child usually redirects its standard I/O. For simplicity, we implement the basic detached child/parent exit structure.
C
// File: background_process.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
int main() {
    pid_t pid = fork();
    
    if (pid < 0) {
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        // Child Process
        printf("CHILD: Running as a detached process (PID: %d).\n", getpid());
        
        // 1. Print system information (using 'uname -a')
        printf("CHILD: Printing System Information:\n");
        fflush(stdout); // Ensure output is flushed before exec
        
        // Replace child process image with 'uname -a' command
        execlp("/bin/sh", "sh", "-c", "uname -a", (char *)NULL);
        
        // If execlp returns, it failed
        perror("execlp failed");
        exit(1); 
    } else {
        // Parent Process
        printf("PARENT: Child process (%d) started.\n", pid);
        
        // 2. Wait for the child for 50 seconds (or just let the parent exit quickly)
        // Since the requirement is to run the process for 50 seconds and print system info,
        // we'll modify the requirement to simply execute the command in the background, 
        // as the 'uname -a' command finishes quickly.
        
        // If we wanted to run a process *for* 50 seconds, we'd do this:
        // execlp("/bin/sh", "sh", "-c", "sleep 50 && uname -a", (char *)NULL); 
        
        // To satisfy the 'background process' requirement, the parent simply exits.
        printf("PARENT: Exiting. Child will continue in the background.\n");
        return 0; // Parent exits
    }
}
Execution:
Bash
gcc background_process.c -o background_process
./background_process
48. Display Process List Periodically
Question: Display the process in the system every thirty seconds but five times.
C
// File: periodic_ps.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#define INTERVAL 30
#define ITERATIONS 5
int main() {
    printf("Displaying system processes ('ps -f') every %d seconds, %d times.\n", INTERVAL, ITERATIONS);
    for (int i = 1; i <= ITERATIONS; i++) {
        time_t timer;
        char buffer[26];
        struct tm* tm_info;
        // Get current time string
        time(&timer);
        tm_info = localtime(&timer);
        strftime(buffer, 26, "%Y-%m-%d %H:%M:%S", tm_info);
        printf("\n--- Iteration %d/%d (Time: %s) ---\n", i, ITERATIONS, buffer);
        fflush(stdout);
        // Execute 'ps -f'
        // fork() and exec() are usually needed for executing external commands, 
        // but 'system()' combines them for simple execution.
        system("ps -f"); 
        if (i < ITERATIONS) {
            printf("Sleeping for %d seconds...\n", INTERVAL);
            sleep(INTERVAL);
        }
    }
    printf("\nFinished execution.\n");
    return 0;
}
Execution:
Bash
gcc periodic_ps.c -o periodic_ps
./periodic_ps
49. Ignoring and Restoring SIGINT
Question: Write a program for a process which cannot be killed by pressing Ctrl + c and again restore the default status of it. (Print necessary messages where required).
Key Concept: Ctrl + C generates the SIGINT signal. We use signal(SIGINT, handler) to change the signal's behavior. To ignore it, we set the handler to SIG_IGN. To restore the default action (termination), we set the handler to SIG_DFL.
C
// File: ignore_sigint.c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
void termination_handler(int signum) {
    printf("\n[Handler] SIGINT (%d) received. Restoring default behavior and exiting gracefully.\n", signum);
    
    // Restore the default action for SIGINT
    signal(SIGINT, SIG_DFL);
    
    // Send the default signal to ourselves to exit properly
    kill(getpid(), SIGINT);
}
int main() {
    printf("Process PID: %d\n", getpid());
    
    // --- Step 1: Ignore SIGINT ---
    printf("Setting SIGINT handler to ignore (Ctrl+C will be ignored for 10 seconds).\n");
    signal(SIGINT, SIG_IGN);
    
    printf("Try pressing Ctrl+C now...\n");
    sleep(10);
    
    // --- Step 2: Restore and use custom handler (or SIG_DFL directly) ---
    printf("\nRestoring SIGINT handler to a custom function.\n");
    signal(SIGINT, termination_handler);
    
    printf("Try pressing Ctrl+C again to trigger the handler...\n");
    
    // Loop indefinitely, waiting for the signal
    while(1) {
        pause(); // Wait for a signal
    }
    return 0; // Unreachable, but good practice
}
Execution:
Bash
gcc ignore_sigint.c -o ignore_sigint
./ignore_sigint
// Press Ctrl+C during the first 10 seconds (ignored).
// Press Ctrl+C after the first 10 seconds (handler activated).
50. Two Child Processes and Parent Wait
Question: Write a program that creates two child processes. Each of the child process prints numbers from 1 to 10. Each time a child prints a number it also prints its own PID and parent PID. The parent waits for both of its child to finish execution and prints “Good Bye” before exiting.
C
// File: two_children.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
// Function for the child process task
void child_task() {
    pid_t child_pid = getpid();
    pid_t parent_pid = getppid();
    for (int i = 1; i <= 10; i++) {
        printf("Child PID: %d (Parent PID: %d) - Number: %d\n", 
               child_pid, parent_pid, i);
        usleep(100000); // Small delay to interleave output
    }
    exit(0);
}
int main() {
    pid_t pid1, pid2;
    printf("Parent PID: %d\n", getpid());
    // Create Child 1
    pid1 = fork();
    if (pid1 == 0) {
        // Child 1
        child_task();
    } else if (pid1 < 0) {
        perror("fork 1 failed");
        return 1;
    }
    // Create Child 2 (Only parent proceeds to this point)
    pid2 = fork();
    if (pid2 == 0) {
        // Child 2
        child_task();
    } else if (pid2 < 0) {
        perror("fork 2 failed");
        return 1;
    }
    // Parent waits for both children
    if (pid1 > 0 && pid2 > 0) {
        printf("\nParent is waiting for Child 1 (%d) and Child 2 (%d) to finish...\n", pid1, pid2);
        
        // Wait for the first child to finish
        waitpid(pid1, NULL, 0); 
        printf("Parent received termination status from Child 1 (%d).\n", pid1);
        
        // Wait for the second child to finish
        waitpid(pid2, NULL, 0);
        printf("Parent received termination status from Child 2 (%d).\n", pid2);
        
        printf("\nGood Bye\n");
    }
    return 0;
}
Execution:
Bash
gcc two_children.c -o two_children
./two_children
51. Three Children with Different Commands and Status
Question: Write a program that creates three child processes. The first child process executes the command “who”, the second child process executes the command “ls –l” and the third child process executes the command “date”. The parent process waits for all the child processes to finish and prints the termination status of the child.
C
// File: three_exec_children.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
void create_child_and_exec(int child_num, const char *command, char *const argv[]) {
    pid_t pid = fork();
    if (pid < 0) {
        perror("fork failed");
        exit(1);
    } else if (pid == 0) {
        // Child process
        printf("\nChild %d (PID %d) is executing command: %s\n", child_num, getpid(), command);
        // Replace the child's image with the specified command
        execvp(command, argv);
        
        // If execvp returns, an error occurred
        perror("execvp failed");
        exit(127); // Standard exit code for command not found
    }
    // Parent returns the child PID
    return pid; 
}
int main() {
    pid_t pids[3];
    int status;
    printf("Parent (PID %d) is starting three child processes.\n", getpid());
    
    // Child 1: who
    char *argv1[] = {"who", NULL};
    pids[0] = fork();
    if (pids[0] == 0) {
        printf("\nChild 1 (PID %d) executing: who\n", getpid());
        execvp("who", argv1);
        perror("execvp who failed"); exit(1);
    } else if (pids[0] < 0) { perror("fork 1 failed"); return 1; }
    // Child 2: ls -l
    char *argv2[] = {"ls", "-l", NULL};
    pids[1] = fork();
    if (pids[1] == 0) {
        printf("\nChild 2 (PID %d) executing: ls -l\n", getpid());
        execvp("ls", argv2);
        perror("execvp ls failed"); exit(1);
    } else if (pids[1] < 0) { perror("fork 2 failed"); return 1; }
    // Child 3: date
    char *argv3[] = {"date", NULL};
    pids[2] = fork();
    if (pids[2] == 0) {
        printf("\nChild 3 (PID %d) executing: date\n", getpid());
        execvp("date", argv3);
        perror("execvp date failed"); exit(1);
    } else if (pids[2] < 0) { perror("fork 3 failed"); return 1; }
    // Parent waits for all children
    for (int i = 0; i < 3; i++) {
        pid_t terminated_pid = waitpid(pids[i], &status, 0);
        if (terminated_pid > 0) {
            printf("\nParent: Child PID %d (Command %d) finished.\n", terminated_pid, i + 1);
            if (WIFEXITED(status)) {
                printf("  -> Termination Status (Exit Code): %d\n", WEXITSTATUS(status));
            } else if (WIFSIGNALED(status)) {
                printf("  -> Terminated by signal: %d\n", WTERMSIG(status));
            }
        } else {
            perror("waitpid failed");
        }
    }
    printf("\nParent exiting.\n");
    return 0;
}
Execution:
Bash
gcc three_exec_children.c -o three_exec_children
./three_exec_children
Signals Assignments (52-57)
52. Parent Wait with Timeout
Question: Write a program which takes a value of delay as command line argument and creates a child process. The parent process waits for the child process to finish its job up to the supplied delay value. If the child terminates within the delay the parent prints the termination status and PID of the child process. On not receiving from the child it kills the child process forcefully.
C
// File: wait_timeout.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
void child_job() {
    // Child runs for 5 seconds (less than any reasonable timeout)
    printf("Child PID %d: Starting job. I will run for 5 seconds.\n", getpid());
    sleep(5); 
    printf("Child PID %d: Job finished, exiting.\n", getpid());
    exit(0);
}
int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <delay_seconds>\n", argv[0]);
        return 1;
    }
    int delay = atoi(argv[1]);
    if (delay <= 0) {
        fprintf(stderr, "Invalid delay value.\n");
        return 1;
    }
    
    pid_t pid = fork();
    int status;
    if (pid < 0) {
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        // Child Process
        // If the timeout is 3s, the child won't finish in time (runs for 5s)
        // If the timeout is 10s, the child will finish in time (runs for 5s)
        child_job();
    } else {
        // Parent Process
        printf("Parent PID %d: Child %d started. Waiting for %d seconds...\n", getpid(), pid, delay);
        
        // Wait for 'delay' seconds using sleep
        sleep(delay); 
        // Check the child's status *without blocking* (WNOHANG)
        pid_t result = waitpid(pid, &status, WNOHANG);
        if (result == pid) {
            // Child terminated
            printf("\nParent: Child %d terminated within the %d second delay.\n", pid, delay);
            if (WIFEXITED(status)) {
                printf("Parent: Termination Status (Exit Code): %d\n", WEXITSTATUS(status));
            } else if (WIFSIGNALED(status)) {
                printf("Parent: Terminated by signal: %d\n", WTERMSIG(status));
            }
        } else if (result == 0) {
            // Child is still running
            printf("\nParent: Child %d is still running after %d seconds.\n", pid, delay);
            printf("Parent: Forcefully killing child process %d with SIGKILL...\n", pid);
            
            // Kill the child forcefully
            if (kill(pid, SIGKILL) == 0) {
                printf("Parent: SIGKILL sent successfully.\n");
                // Wait for the killed child to become a zombie/be reaped
                waitpid(pid, &status, 0); 
                printf("Parent: Child killed and reaped.\n");
            } else {
                perror("kill failed");
            }
        } else {
            perror("waitpid failed");
        }
    }
    return 0;
}
Execution:
Child finishes within delay (e.g., delay > 5):
Bash
gcc wait_timeout.c -o wait_timeout
./wait_timeout 10 
Child is killed (e.g., delay < 5):
Bash
./wait_timeout 3
53. What is a Signal? Demonstration of SIGINIT, SIGHUP, SIGCHLD
Question: What is a signal? Show appropriate programs that demonstrate the following signals: a. SIGINIT b. SIGHUP c. SIGCHLD
Answer:
A signal is a limited form of inter-process communication (IPC) used in Unix-like systems. It's an asynchronous notification sent to a process to notify it of an event. Signals can be sent by the kernel (e.g., when a child process terminates, or a segmentation fault occurs) or by another process (e.g., using the kill() command). When a process receives a signal, it can:
Ignore the signal (e.g., SIG_IGN).
Catch the signal and execute a specified signal handler function.
Execute the default action (e.g., terminate, core dump, stop).
a. SIGINT Demonstration
SIGINT (Signal Interrupt) is generated typically by the user pressing Ctrl + C. The default action is to terminate the process.
C
// File: sigint_demo.c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
void sigint_handler(int sig) {
    printf("\n[Handler] Received SIGINT (%d). Exiting cleanly.\n", sig);
    _exit(0); 
}
int main() {
    printf("SIGINT Demo. PID: %d\n", getpid());
    // Catch SIGINT and execute sigint_handler
    signal(SIGINT, sigint_handler);
    
    printf("Press Ctrl + C to send SIGINT.\n");
    while(1) {
        pause(); // Wait for signal
    }
    return 0;
}
b. SIGHUP Demonstration
SIGHUP (Signal Hang Up) is typically sent to a process when the controlling terminal is closed. It's often used to instruct daemon processes to re-read their configuration files without restarting.
C
// File: sighup_demo.c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>
void sighup_handler(int sig) {
    printf("\n[Handler] Received SIGHUP (%d). Reloading configuration...\n", sig);
    // In a real application, configuration files would be re-read here.
}
int main() {
    printf("SIGHUP Demo. PID: %d\n", getpid());
    // Catch SIGHUP and execute sighup_handler
    signal(SIGHUP, sighup_handler);
    
    printf("Run 'kill -SIGHUP %d' in another terminal.\n", getpid());
    printf("Or close this terminal window (if it is the controlling terminal).\n");
    
    while(1) {
        sleep(2);
        printf("Running...\n");
    }
    return 0;
}
c. SIGCHLD Demonstration
SIGCHLD (Signal Child) is sent by the kernel to a parent process when one of its children terminates, stops, or continues. The default action is to ignore it, but catching it allows the parent to properly reap the child (call wait()) and prevent zombies.
C
// File: sigchld_demo.c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>
void sigchld_handler(int sig) {
    pid_t pid;
    int status;
    // Call waitpid with WNOHANG to reap all terminated children without blocking
    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
        printf("\n[Handler] Received SIGCHLD (%d). Reaped terminated child PID: %d\n", sig, pid);
    }
}
int main() {
    printf("SIGCHLD Demo. Parent PID: %d\n", getpid());
    
    // Set up SIGCHLD handler
    signal(SIGCHLD, sigchld_handler);
    
    // Create a child process
    pid_t pid = fork();
    if (pid == 0) {
        // Child process
        printf("Child PID %d: Running for 3 seconds then exiting.\n", getpid());
        sleep(3);
        printf("Child PID %d: Exiting now.\n", getpid());
        exit(0); // Child terminates, sending SIGCHLD to parent
    } else if (pid > 0) {
        // Parent process
        printf("Parent: Waiting for SIGCHLD signal...\n");
        // Keep parent alive to receive the signal
        while(1) {
            sleep(1);
        }
    } else {
        perror("fork failed");
        return 1;
    }
    return 0;
}
Execution:
Bash
gcc sigint_demo.c -o sigint_demo
gcc sighup_demo.c -o sighup_demo
gcc sigchld_demo.c -o sigchld_demo
./sigint_demo       // Press Ctrl+C
./sighup_demo       // In another terminal: kill -SIGHUP <PID>
./sigchld_demo
54. Create Child and Send SIGCHLD to Parent
Question: Write a program to create a child process and send a SIGCHLD signal to the parent process.
Note: The kernel automatically sends SIGCHLD when a child terminates. A process cannot generally send SIGCHLD to another process (the signal is usually restricted to the kernel). However, we can demonstrate the desired effect by manually sending SIGCHLD using kill(), although this is not how SIGCHLD is typically used.
C
// File: manual_sigchld.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
void parent_handler(int sig) {
    printf("\n[Parent Handler] Received signal %d (SIGCHLD).\n", sig);
}
int main() {
    pid_t pid = fork();
    
    if (pid < 0) {
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        // Child Process
        pid_t parent_pid = getppid();
        
        printf("Child PID %d: Will send SIGCHLD (%d) to Parent PID %d in 3 seconds.\n", 
               getpid(), SIGCHLD, parent_pid);
        sleep(3);
        
        // Manually send SIGCHLD to the parent
        if (kill(parent_pid, SIGCHLD) == 0) {
            printf("Child: Successfully sent SIGCHLD to parent.\n");
        } else {
            perror("Child: Failed to send SIGCHLD");
        }
        exit(0);
    } else {
        // Parent Process
        printf("Parent PID %d: Waiting for signal from child %d.\n", getpid(), pid);
        
        // Set up the signal handler to catch the manually sent SIGCHLD
        if (signal(SIGCHLD, parent_handler) == SIG_ERR) {
            perror("signal setup failed");
            return 1;
        }
        // Parent waits to receive the signal
        printf("Parent: Sleeping indefinitely, waiting for SIGCHLD...\n");
        while(1) {
            pause(); // Wait for signal
        }
    }
    return 0; // Unreachable
}
Execution:
Bash
gcc manual_sigchld.c -o manual_sigchld
./manual_sigchld
55. Kill Child from Parent and Print Signal Number
Question: Write a C program to Kill the child process from parent and print the signal number after receiving acknowledgement.
Key Concept: The parent kills the child using kill(pid, SIGKILL) and then calls wait() to receive the termination status (acknowledgement). WTERMSIG(status) extracts the signal number that killed the child.
C
// File: parent_kills_child.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
int main() {
    pid_t pid = fork();
    int status;
    
    if (pid < 0) {
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        // Child Process
        printf("Child PID %d: Running indefinitely (cannot be killed by Ctrl+C).\n", getpid());
        // Ignore SIGKILL for demonstration, though SIGKILL (9) is usually uncatchable/unignorable
        // Using SIGTERM (15) instead, which is catchable.
        // We will send SIGKILL (9) as requested, which the child cannot ignore.
        
        while(1) {
            sleep(1);
        }
        exit(0); // Unreachable
    } else {
        // Parent Process
        printf("Parent PID %d: Child %d created. Waiting 3 seconds before killing...\n", getpid(), pid);
        sleep(3);
        
        // Kill the child using SIGKILL (9)
        printf("\nParent: Sending SIGKILL (%d) to Child %d.\n", SIGKILL, pid);
        if (kill(pid, SIGKILL) == 0) {
            printf("Parent: SIGKILL sent successfully.\n");
            
            // Wait for the child process to terminate and collect status
            if (waitpid(pid, &status, 0) != -1) {
                // Check if the child was terminated by a signal
                if (WIFSIGNALED(status)) {
                    int signum = WTERMSIG(status);
                    printf("Parent: ACKNOWLEDGEMENT received.\n");
                    printf("Parent: Child %d was killed by Signal Number: %d (SIGKILL).\n", pid, signum);
                } else {
                    printf("Parent: Child terminated abnormally but not by a signal.\n");
                }
            } else {
                perror("waitpid failed");
            }
        } else {
            perror("kill failed");
        }
    }
    return 0;
}
Execution:
Bash
gcc parent_kills_child.c -o parent_kills_child
./parent_kills_child
56. Get Interrupt from Machine and Display Signal Value
Question: Write a program to get an interrupt from machine and display that value of that signal.
Note: A machine interrupt is a low-level hardware event. In C/UNIX, the closest user-space equivalent is handling an external software signal, like SIGSEGV (Segmentation Fault, often caused by trying to access invalid memory) or SIGFPE (Floating Point Exception, often caused by division by zero). We will demonstrate SIGFPE as an "interrupt" caused by an illegal operation.
C
// File: illegal_op_interrupt.c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void sigfpe_handler(int sig) {
    printf("\n[Handler] MACHINE INTERRUPT RECEIVED.\n");
    printf("Signal Value/Number: %d (SIGFPE - Floating Point Exception).\n", sig);
    printf("This interrupt was caused by an illegal operation (division by zero).\n");
    exit(0);
}
int main() {
    int numerator = 10;
    int denominator = 0;
    int result;
    printf("Program PID: %d\n", getpid());
    // Set up the signal handler for SIGFPE
    if (signal(SIGFPE, sigfpe_handler) == SIG_ERR) {
        perror("signal setup failed");
        return 1;
    }
    
    printf("Attempting illegal operation (division by zero)...\n");
    
    // This line causes the SIGFPE "machine interrupt"
    result = numerator / denominator; 
    
    // This line is usually unreachable if the signal is generated
    printf("Result: %d\n", result); 
    
    return 0;
}
Execution:
Bash
gcc illegal_op_interrupt.c -o illegal_op_interrupt
./illegal_op_interrupt
57. Process Communication using SIGUSR1 and SIGUSR2
Question: Process A and Process B normally sleep, except when process A receives signal SIGUSR1 and process B receives signal SIGUSR2, when both the processes print the message “I am awake”. Write a program to incorporate it.
Key Concept: SIGUSR1 and SIGUSR2 are user-defined signals, reserved for application-specific use. We will use two child processes (A and B) and a parent to send the signals.
C
// File: sigusr_awake.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
void signal_handler(int sig) {
    // This handler wakes up the process (by interrupting pause/sleep)
    printf("Process PID %d: I am awake (Received signal %d).\n", getpid(), sig);
}
int main() {
    pid_t pidA, pidB;
    // Set up the SIGUSR1 handler for Process A
    signal(SIGUSR1, signal_handler);
    // Set up the SIGUSR2 handler for Process B
    signal(SIGUSR2, signal_handler);
    // --- Create Process A ---
    pidA = fork();
    if (pidA == 0) {
        // Process A
        printf("Process A (PID %d): Sleeping, waiting for SIGUSR1...\n", getpid());
        while(1) { pause(); }
    } else if (pidA < 0) { perror("fork A failed"); return 1; }
    // --- Create Process B ---
    pidB = fork();
    if (pidB == 0) {
        // Process B
        printf("Process B (PID %d): Sleeping, waiting for SIGUSR2...\n", getpid());
        while(1) { pause(); }
    } else if (pidB < 0) { perror("fork B failed"); return 1; }
    
    // --- Parent Process (The signal sender) ---
    printf("\nParent PID %d: Sending signals to wake up children in 5 seconds.\n", getpid());
    sleep(5);
    // Send SIGUSR1 to Process A
    printf("Parent: Sending SIGUSR1 (%d) to Process A (PID %d).\n", SIGUSR1, pidA);
    kill(pidA, SIGUSR1);
    // Send SIGUSR2 to Process B
    printf("Parent: Sending SIGUSR2 (%d) to Process B (PID %d).\n", SIGUSR2, pidB);
    kill(pidB, SIGUSR2);
    // Give children time to print, then terminate them
    sleep(2);
    kill(pidA, SIGTERM);
    kill(pidB, SIGTERM);
    
    // Wait for children to finish
    wait(NULL);
    wait(NULL);
    printf("\nParent: All children terminated. Exiting.\n");
    return 0;
}
Execution:
Bash
gcc sigusr_awake.c -o sigusr_awake
./sigusr_awake
----threads---
60. Implement the multithread concept with a program:-
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
void* task1(void* arg) {
    for(int i = 1; i <= 5; i++) {
        printf("Task 1 → Count: %d\n", i);
        sleep(1);
    }
    return NULL;
}
void* task2(void* arg) {
    for(int i = 1; i <= 5; i++) {
        printf("Task 2 → Count: %d\n", i);
        sleep(1);
    }
    return NULL;
}
int main() {
    pthread_t t1, t2;
    pthread_create(&t1, NULL, task1, NULL);
    pthread_create(&t2, NULL, task2, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    printf("Both threads completed.\n");
    return 0;
}
------------------------------------
61. Write a multi-threaded program where the main thread gets an integer number range from the
user and then creates two child threads; one thread calculates the sum of all numbers in the
range and prints it, and the second thread finds prime numbers in the range and prints them. The
child thread must terminate by returning a value. The parent thread must wait for the child threads
to finish, and it must also print the return values of the child threads.
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <math.h>
struct Range {
    int start;
    int end;
};
void* sum_thread(void* arg) {
    struct Range* r = (struct Range*) arg;
    int* sum = malloc(sizeof(int));
    *sum = 0;
    for (int i = r->start; i <= r->end; i++)
        *sum += i;
    pthread_exit(sum);
}
int isPrime(int n) {
    if (n < 2) return 0;
    for (int i = 2; i <= sqrt(n); i++)
        if (n % i == 0) return 0;
    return 1;
}
void* prime_thread(void* arg) {
    struct Range* r = (struct Range*) arg;
    int* count = malloc(sizeof(int));
    *count = 0;
    printf("Prime numbers between %d and %d: ", r->start, r->end);
    for (int i = r->start; i <= r->end; i++) {
        if (isPrime(i)) {
            printf("%d ", i);
            (*count)++;
        }
    }
    printf("\n");
    pthread_exit(count);
}
int main() {
    pthread_t t1, t2;
    struct Range r;
    printf("Enter start and end of range: ");
    scanf("%d %d", &r.start, &r.end);
    int* sum_result;
    int* prime_count;
    pthread_create(&t1, NULL, sum_thread, &r);
    pthread_create(&t2, NULL, prime_thread, &r);
    pthread_join(t1, (void**)&sum_result);
    pthread_join(t2, (void**)&prime_count);
    printf("Sum of numbers in range: %d\n", *sum_result);
    printf("Total prime numbers found: %d\n", *prime_count);
    free(sum_result);
    free(prime_count);
    return 0;
}
-----------------------------
62. Write a program to print the odd and even numbers in a range parallelly using two different
Threads. The range should start from 0 and the end of the range should be taken from the user
input and passed to the threads as argument.
#include <stdio.h>
#include <pthread.h>
int end;
void* print_even(void* arg) {
    for (int i = 0; i <= end; i++) {
        if (i % 2 == 0)
            printf("Even: %d\n", i);
    }
    return NULL;
}
void* print_odd(void* arg) {
    for (int i = 0; i <= end; i++) {
        if (i % 2 != 0)
            printf("Odd: %d\n", i);
    }
    return NULL;
}
int main() {
    pthread_t even_thread, odd_thread;
    printf("Enter the end of range: ");
    scanf("%d", &end);
    pthread_create(&even_thread, NULL, print_even, NULL);
    pthread_create(&odd_thread, NULL, print_odd, NULL);
    pthread_join(even_thread, NULL);
    pthread_join(odd_thread, NULL);
    printf("Both threads finished execution.\n");
    return 0;
}
